<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.4.0/dist/leaflet.css" />
      <script src="https://d3js.org/d3.v4.min.js" type="text/javascript"></script>
		<script src="https://d3js.org/d3-geo.v1.min.js"></script>
    <script src="https://unpkg.com/leaflet@1.4.0/dist/leaflet.js"></script>
    <script src='https://api.tiles.mapbox.com/mapbox.js/v1.6.4/mapbox.js'></script>
    <link href='https://api.tiles.mapbox.com/mapbox.js/v1.6.4/mapbox.css' rel='stylesheet' />
    <style>
    html,
    body {
        height: 100%;
        width: 100%;
        margin: 0;
    }
    #map {
				left: 0;
				right: 0;
				margin: auto;
				text-align: center;
        width: 100%;
        height: 100%;
    }
    svg {
        position: relative;
    }
    path {
        fill: yellow;
        stroke-width: 2px;
        stroke: red;
        stroke-opacity: 1;
    }
    .travelMarker {
        fill: green;
        opacity: 0.75;
    }
    .waypoints {
        fill: black;
        opacity: 0;
    }
		.start_end_point {
		    stroke: black;
		    fill: red;
		}
		.lineConnect {
		    fill: none;
		    stroke: black;
		    opacity: 1;
		}
		.locnames {
		    fill: black;
		    text-shadow: 1px 1px 1px #FFF, 3px 3px 5px #000;
		    font-weight: bold;
		    font-size: 13px;
		}
    </style>
</head>
<body>
<div id="map"></div>
<script type="text/javascript">
const streets  = L.tileLayer(
  'https://api.tiles.mapbox.com/v4/{id}/{z}/{x}/{y}.png?access_token=pk.eyJ1Ijoia3Jpc3RpbmhlbnJ5IiwiYSI6ImNqMWdxMjd5aDAwM28zM2xtaGV2azYwcjYifQ.NTJiOqcnhP-_3etf4aZYmQ',
  { id: 'mapbox.streets',   attribution: 'Map data &copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors, <a href="http://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, Imagery Â© <a href="http://mapbox.com">Mapbox</a>' });

const map = L.map('map', {layers: [streets]}).setView([-3.4092, -52.6794], 8);

// we will be appending the SVG to the Leaflet map pane
// g (group) element will be inside the svg
const svg = d3.select(map.getPanes().overlayPane).append("svg");

// if you don't include the leaflet-zoom-hide when a
// user zooms in or out you will still see the phantom
// original SVG
const g = svg.append("g").attr("class", "leaflet-zoom-hide");

const transform = d3.geoTransform({ point: projectPoint });
const d3path = d3.geoPath().projection(transform);

d3.json("https://raw.githubusercontent.com/felipemartenexen/pdrsx/master/trajeto_app_3.geojson", function(collection) {
  const featuresdata = collection.features;
  
    
  // Here we're creating a FUNCTION to generate a line
  // from input points. Since input points will be in
  // Lat/Long they need to be converted to map units
  // with applyLatLngToLayer
  const toLine = d3.line()
      .curve(d3.curveLinear)
      .x((d) => applyLatLngToLayer(d).x)
      .y((d) => applyLatLngToLayer(d).y);

  // From now on we are essentially appending our features to the
  // group element. We're adding a class with the line name
  // and we're making them invisible

  // these are the points that make up the path
  // they are unnecessary so I've make them
  // transparent for now
  var ptFeatures = g.selectAll("circle")
      .data(featuresdata)
      .enter()
      .append("circle")
      .attr("r", 3)
      .attr("class", "waypoints");

  // Here we will make the points into a single
  // line/path. Note that we surround the featuresdata
  // with [] to tell d3 to treat all the points as a
  // single line. For now these are basically points
  // but below we set the "d" attribute using the
  // line creator function from above.
  var linePath = g.selectAll(".lineConnect")
      .data([featuresdata])
      .enter()
      .append("path")
      .attr("class", "lineConnect");

  // This will be our traveling circle it will
  // travel along our path
  var marker = g.append("circle")
      .attr("r", 10)
      .attr("id", "marker")
      .attr("class", "travelMarker");

  var marker_start = g.selectAll("g.start_end_point")
      .data([featuresdata[0]])
      .enter()
      .append('g')
      .attr('class', '.start_end_point');

  marker_start
      .append("circle", )
      .attr("r", 5)
      .style("fill", "red")
      .style("opacity", "1");

  marker_start
      .append("text")
      .text('IA')
      .attr("class", "locnames")
      .attr("y", -10);

  // when the user zooms in or out you need to reset
  // the view
  map.on("viewreset", reset);


  
  // this puts stuff on the map!
  reset();
  transition();

  // Reposition the SVG to cover the features.
  function reset() {
      var bounds = d3path.bounds(collection),
          topLeft = bounds[0],
          bottomRight = bounds[1];

      marker_start.attr("transform", d => "translate(" + applyLatLngToLayer(d).x + "," + applyLatLngToLayer(d).y + ")");
      ptFeatures.attr("transform", d => "translate(" + applyLatLngToLayer(d).x + "," + applyLatLngToLayer(d).y + ")");
      marker.attr("transform", function() {
            const coords = featuresdata[0].geometry.coordinates;
						const pt = map.latLngToLayerPoint(new L.LatLng(coords[1], coords[0]));
            return "translate(" + pt.x + "," + pt.y + ")";
        });

      // Setting the size and location of the overall SVG container
      svg.attr("width", bottomRight[0] - topLeft[0] + 120)
          .attr("height", bottomRight[1] - topLeft[1] + 120)
          .style("left", topLeft[0] - 50 + "px")
          .style("top", topLeft[1] - 50 + "px");

      linePath.attr("d", toLine)
      g.attr("transform", "translate(" + (-topLeft[0] + 50) + "," + (-topLeft[1] + 50) + ")");

  } // end reset

  // the transition function could have been done above using
  // chaining but it's cleaner to have a separate function.
  // the transition. Dash array expects "500, 30" where
  // 500 is the length of the "dash" 30 is the length of the
  // gap. So if you had a line that is 500 long and you used
  // "500, 0" you would have a solid line. If you had "500,500"
  // you would have a 500px line followed by a 500px gap. This
  // can be manipulated by starting with a complete gap "0,500"
  // then a small line "1,500" then bigger line "2,500" and so
  // on. The values themselves ("0,500", "1,500" etc) are being
  // fed to the attrTween operator
  function transition() {
      linePath.transition()
          .duration(40000)
          .attrTween("stroke-dasharray", tweenDash)
          .on("end", transition); // Restart the transition at it's end
  } //end transition

  // this function feeds the attrTween operator above with the
  // stroke and dash lengths
  function tweenDash() {
      return function(t) {
          //total length of path (single value)
          var l = linePath.node().getTotalLength();

          // this is creating a function called interpolate which takes
          // as input a single value 0-1. The function will interpolate
          // between the numbers embedded in a string. An example might
          // be interpolatString("0,500", "500,500") in which case
          // the first number would interpolate through 0-500 and the
          // second number through 500-500 (always 500). So, then
          // if you used interpolate(0.5) you would get "250, 500"
          // when input into the attrTween above this means give me
          // a line of length 250 followed by a gap of 500. Since the
          // total line length, though is only 500 to begin with this
          // essentially says give me a line of 250px followed by a gap
          // of 250px.
          interpolate = d3.interpolateString("0," + l, l + "," + l);
          //t is fraction of time 0-1 since transition began

          // p is the point on the line (coordinates) at a given length
          // along the line. In this case if l=50 and we're midway through
          // the time then this would 25.
          var p = linePath.node().getPointAtLength(t * l);

          //Move the marker to that point
          marker.attr("transform", "translate(" + p.x + "," + p.y + ")"); //move marker
          return interpolate(t);
      }
  } //end tweenDash
});

function projectPoint(x, y) {
    var point = map.latLngToLayerPoint(new L.LatLng(y, x));
    this.stream.point(point.x, point.y);
}

// similar to projectPoint this function converts lat/long to
// svg coordinates except that it accepts a point from our
// GeoJSON
function applyLatLngToLayer(d) {
    return map.latLngToLayerPoint(
			new L.LatLng(d.geometry.coordinates[1], d.geometry.coordinates[0]));
}
</script>
</body>
</html>
